1. Bubble Sort
    In case of bubble sort we sort out the biggest or smallest element to the end of the array. We do this by starting
    from beginning and then compare first two elements and then next two and keep going like that.

    A. Bubble sort moves the largest element at the end of the list, can do vice versa too.
    B. We use outer loop from n-1 to 0 where largest value is moved to last cell every iteration of inner loop.
    C. Inner loop starts from 0- n-1 and compares and swaps n+1 to n every iteration.

2. Selection Sort
    In case of selection sort we use a marker and we start by comparing first element with every element after it.
    once we find a smaller element we mark it as smallest. at the end of every inner loop we swap outer loop element with the
    marked element.

    A. Selection sort is similar to bubble sort but we do not swap every inner loop iteration.
    B. In selection sort we start outer loop 0-n-1 and inner loop i+1 - n-1.
    C. We add a flag to the 0th value in the array initially assuming its smallest.
    D. Every inner loop we compare every value from i+1 to n-1 with the flagged value.
    E. if we find any value smaller than flagged value we flag the new value.
    F. After complete inner loop we find the smallest value and we assign it to ith node.

3. Insertion Sort:

    A. In Insertion sort we leave the first cell and start from 1 to n-1
    B. Before starting second loop we save the first value.
    C. we start the second loop from i -> 0 and we check if i-1 th value is greater than saved value.
    D. if i-1 th value is greater than saved value then we move the i-1th value to ith and we keep doing it until we reach 0.
    E. At the end we save the temp value to left most cell left empty.

4. Shell Sort:
    A.

5. Merge Sort:
    A. From http://www.java2novice.com/java-sorting-algorithms/merge-sort/
    B. Merge sort is based on divide and conquer approach.
    C. You divide a bigger array/linkedlist into smaller parts and you sort them and then merge them into a single array.
    D. This is a stable sort i.e. the order in which equal items appear in the input are received in the output.
    E. In merge sort you need additional space to save merged array equal to size of actual array.
    F.

6. Partitioning:
    A. We do partitioning when we want to separate out items less than and greater than a certain item in an array.
    B. Partitioning is a step in quick sort algorithm.
    C. We send the algorithm the left most and the right most element of the array.
    D. We use two pointers one pointing to left=start-1 and other pointing to right=end+1 position of array.
    E. We start a loop where we keep incrementing and decrementing values from both ends.
    F. The increment and decrement is done so that left pointer cannot cross right and vice versa. If the left item is
       greater than pivot or the right item is smaller than pivot we simply increment/decrement them.
    G. Every step if left<=right we swap the elements.

7. Quick Sort:
    A.

